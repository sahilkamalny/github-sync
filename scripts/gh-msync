#!/bin/bash

# ==========================================
# GitHub Multi-Sync — Repository Sync Utility
# ==========================================

CONFIG_DIR="$HOME/.config/gh-msync"
CONFIG_FILE="$CONFIG_DIR/config"

resolve_script_dir() {
    local source="${BASH_SOURCE[0]}"
    local dir target

    while [ -L "$source" ]; do
        dir="$(cd -P "$(dirname "$source")" && pwd)"
        target="$(readlink "$source")"
        if [[ "$target" == /* ]]; then
            source="$target"
        else
            source="$dir/$target"
        fi
    done

    cd -P "$(dirname "$source")" && pwd
}

trim_whitespace() {
    local value="$1"
    value="${value#"${value%%[![:space:]]*}"}"
    value="${value%"${value##*[![:space:]]}"}"
    printf '%s' "$value"
}

string_display_width() {
    local text="$1"
    local width

    width="$(printf '%s' "$text" | wc -m | tr -d ' ')"
    if [[ ! "$width" =~ ^[0-9]+$ ]]; then
        width="${#text}"
    fi
    printf '%s' "$width"
}

escape_applescript_string() {
    local value="$1"
    value="${value//\\/\\\\}"
    value="${value//\"/\\\"}"
    printf '%s' "$value"
}

expand_home_path() {
    case "$1" in
        "~")
            printf '%s' "$HOME"
            ;;
        "~/"*)
            printf '%s/%s' "$HOME" "${1#~/}"
            ;;
        *)
            printf '%s' "$1"
            ;;
    esac
}

print_usage() {
    cat <<'EOF'
Usage: gh-msync [options] [repo-root ...]

(GitHub Multi-Sync) Sync local Git repositories in parallel.

Options:
  --configure, --config   Launch path configuration UI/CLI and exit
  --cli, --headless       Force terminal-only prompts (no GUI dialogs)
  --no-ssh-upgrade        Do not auto-convert GitHub HTTPS remotes to SSH
  --ssh-upgrade           Explicitly enable GitHub HTTPS -> SSH conversion
  -h, --help              Show this help message and exit

Environment:
  GH_MSYNC_NO_SSH_UPGRADE=1   Disable SSH auto-upgrade by default
EOF
}

RUN_CONFIGURE=0
CONFIGURE_ARGS=()
for arg in "$@"; do
    case "$arg" in
        --configure|--config)
            RUN_CONFIGURE=1
            ;;
        --cli|--headless)
            CONFIGURE_ARGS+=("$arg")
            ;;
    esac
done

if [ "$RUN_CONFIGURE" -eq 1 ]; then
    CONFIGURER=""
    SCRIPT_DIR="$(resolve_script_dir)"
    if [ -x "$SCRIPT_DIR/configure-paths.sh" ]; then
        CONFIGURER="$SCRIPT_DIR/configure-paths.sh"
    elif command -v brew >/dev/null 2>&1; then
        PREFIX="$(brew --prefix gh-msync 2>/dev/null)"
        if [ -n "$PREFIX" ] && [ -x "$PREFIX/libexec/gh-msync-configure" ]; then
            CONFIGURER="$PREFIX/libexec/gh-msync-configure"
        fi
    fi
    if [ -n "$CONFIGURER" ]; then
        exec "$CONFIGURER" "${CONFIGURE_ARGS[@]}"
    else
        echo "gh-msync: configure script not found." >&2
        exit 1
    fi
fi

IS_TTY=0
if [ -t 1 ]; then
    IS_TTY=1
fi

DEFAULT_DIRS=(
    "$HOME/GitHub"
)

CONFIG_DIRS=()
if [ -f "$CONFIG_FILE" ]; then
    while IFS= read -r line || [ -n "$line" ]; do
        line="$(trim_whitespace "$line")"
        [[ -z "$line" || "$line" == \#* ]] && continue
        expanded_path="$(expand_home_path "$line")"
        CONFIG_DIRS+=("$expanded_path")
    done < "$CONFIG_FILE"
fi

FORCE_CLI=0
AUTO_UPGRADE_SSH=1
if [[ "${GH_MSYNC_NO_SSH_UPGRADE:-0}" == "1" ]]; then
    AUTO_UPGRADE_SSH=0
fi
SHOW_HELP=0
ARGS_DIRS=()
END_OF_OPTIONS=0
for arg in "$@"; do
    if [ "$END_OF_OPTIONS" -eq 1 ]; then
        ARGS_DIRS+=("$arg")
        continue
    fi
    case "$arg" in
        --cli|--headless)
            FORCE_CLI=1
            ;;
        --no-ssh-upgrade)
            AUTO_UPGRADE_SSH=0
            ;;
        --ssh-upgrade)
            AUTO_UPGRADE_SSH=1
            ;;
        -h|--help)
            SHOW_HELP=1
            ;;
        --configure|--config)
            # handled earlier
            ;;
        --)
            END_OF_OPTIONS=1
            ;;
        -*)
            echo "gh-msync: unknown option: $arg" >&2
            echo "Run 'gh-msync --help' for usage." >&2
            exit 2
            ;;
        *)
            ARGS_DIRS+=("$arg")
            ;;
    esac
done

if [ "$SHOW_HELP" -eq 1 ]; then
    print_usage
    exit 0
fi

if [ "$IS_TTY" -eq 1 ]; then
    printf '\033[2J\033[3J\033[H'
fi

if [ ${#ARGS_DIRS[@]} -gt 0 ]; then
    BASE_DIRS=("${ARGS_DIRS[@]}")
elif [ "${#CONFIG_DIRS[@]}" -gt 0 ]; then
    BASE_DIRS=("${CONFIG_DIRS[@]}")
else
    BASE_DIRS=("${DEFAULT_DIRS[@]}")
fi

OS="$(uname -s)"

# ---------- Colors ----------
if [ "$IS_TTY" -eq 1 ]; then
    GREEN="\033[1;32m"
    YELLOW="\033[1;33m"
    RED="\033[1;31m"
    BLUE="\033[1;34m"
    CYAN="\033[1;36m"
    RESET="\033[0m"
else
    GREEN=""
    YELLOW=""
    RED=""
    BLUE=""
    CYAN=""
    RESET=""
fi

print_box() {
    local title="$1"
    local border_color="${2:-$BLUE}"
    local title_color="${3:-$CYAN}"
    local title_width
    local inner_width
    local horizontal

    title_width="$(string_display_width "$title")"
    inner_width=$(( title_width + 3 ))
    horizontal="$(printf '%*s' "$inner_width" '' | tr ' ' '━')"
    echo -e "${border_color}┏${horizontal}┓${RESET}"
    echo -e "${border_color}┃${RESET} ${title_color}${title}${RESET}  ${border_color}┃${RESET}"
    echo -e "${border_color}┗${horizontal}┛${RESET}"
}

print_box "➢  GitHub Multi-Sync" "$BLUE" "$CYAN"
echo ""

# ---------- Collect repos ----------
repos=()

for base in "${BASE_DIRS[@]}"; do
    [ -d "$base" ] || continue
    for d in "$base"/*/; do
        [ -d "$d/.git" ] && repos+=("$d")
    done
done

total=${#repos[@]}

# Safety check
if [ "$total" -eq 0 ]; then
    echo -e "    ${YELLOW}△  No Git repositories found in configured directories.${RESET}"
    echo -e "\n\n    ©  2026 Sahil Kamal\n"
    exit 0
fi

# ---------- Header ----------
echo -e "    ${BLUE}↻  Syncing $total repositories...${RESET}"
echo ""

# Arrays to track state (Bash 3 compatible)
pids=()
tmp_files=()
repo_paths=()
before_commits=()
statuses=() # 0=Pulling, 1=Skipped, 2=Error Accessing
ssh_upgraded=() # 1 if origin changed from HTTPS to SSH
GH_REPO_LIST_FILE=""

cleanup_temp_files() {
    local tmp_file
    for tmp_file in "${tmp_files[@]}"; do
        [ -n "$tmp_file" ] && [ -f "$tmp_file" ] && rm -f "$tmp_file"
    done

    if [ -n "$GH_REPO_LIST_FILE" ] && [ -f "$GH_REPO_LIST_FILE" ]; then
        rm -f "$GH_REPO_LIST_FILE"
    fi
}

trap cleanup_temp_files EXIT

count=0
for repo in "${repos[@]}"; do
    repo_paths[$count]="$repo"
    ssh_upgraded[$count]=0
    
    cd "$repo" || {
        statuses[$count]=2
        ((count++))
        continue
    }

    # Detect uncommitted changes
    modified_files=$(git status --porcelain 2>/dev/null | wc -l | tr -d ' ')
    if [[ ! "$modified_files" =~ ^[0-9]+$ ]]; then
        statuses[$count]=2
        ((count++))
        continue
    fi

    if [ "$modified_files" -gt 0 ]; then
        statuses[$count]=1
        ((count++))
        continue
    fi

    # Convert HTTPS → SSH if enabled
    if [ "$AUTO_UPGRADE_SSH" -eq 1 ]; then
        current_url=$(git remote get-url origin 2>/dev/null)
        if [[ "$current_url" == https://github.com/* ]]; then
            ssh_url=$(echo "$current_url" | sed 's|https://github.com/|git@github.com:|')
            if git remote set-url origin "$ssh_url" >/dev/null 2>&1; then
                ssh_upgraded[$count]=1
            fi
        fi
    fi

    statuses[$count]=0
    before_commits[$count]=$(git rev-parse HEAD 2>/dev/null)
    
    tmp=$(mktemp 2>/dev/null || true)
    if [ -z "$tmp" ]; then
        statuses[$count]=2
        ((count++))
        continue
    fi
    tmp_files[$count]="$tmp"
    
    git pull --rebase >"$tmp" 2>&1 &
    pids[$count]=$!
    
    ((count++))
done

# Wait for all background pulls to finish, with an animated spinner
spinner=( "⠋" "⠙" "⠹" "⠸" "⠼" "⠴" "⠦" "⠧" "⠇" "⠏" )
spin_idx=0

while true; do
    jobs_running=0
    for pid in "${pids[@]}"; do
        if kill -0 "$pid" 2>/dev/null; then
            jobs_running=1
            break
        fi
    done
    
    if [ $jobs_running -eq 0 ]; then
        break
    fi
    
    if [ "$IS_TTY" -eq 1 ]; then
        printf "\r    ${BLUE}%s  Fetching updates from GitHub...${RESET}" "${spinner[$spin_idx]}"
    fi
    spin_idx=$(( (spin_idx + 1) % 10 ))
    sleep 0.1
done

# Clear the spinner line
if [ "$IS_TTY" -eq 1 ]; then
    printf "\r\033[K"
fi

# Process and print results sequentially for a clean UI
PAD="    "

display_count=1
for i in "${!repo_paths[@]}"; do
    repo="${repo_paths[$i]}"
    REPO_NAME=$(basename "$repo")
    upgrade_note=""
    if [ "${ssh_upgraded[$i]:-0}" -eq 1 ]; then
        upgrade_note=" (origin switched to SSH)"
    fi
    printf "${PAD}${BLUE}[%d/%d]${RESET} %s " "$display_count" "$total" "$REPO_NAME"
    ((display_count++))
    
    if [ "${statuses[$i]}" -eq 2 ]; then
        echo -e "${BLUE}...${RESET} ${RED}× unable to access repository${RESET}"
        continue
    elif [ "${statuses[$i]}" -eq 1 ]; then
        # We didn't save the modified file count, so we just print skipped
        echo -e "${BLUE}...${RESET} ${YELLOW}△ modified files, sync skipped${RESET}${upgrade_note}"
        continue
    fi
    
    # Check wait status of the specific background job
    wait "${pids[$i]}" 2>/dev/null
    RESULT=$?
    
    cd "$repo" || continue
    after_commit=$(git rev-parse HEAD 2>/dev/null)
    
    if [ $RESULT -ne 0 ]; then
        git rebase --abort 2>/dev/null || true
        echo -e "${BLUE}...${RESET} ${RED}× pull failed (rebase aborted to protect repo)${RESET}${upgrade_note}"
    elif [ "${before_commits[$i]}" = "$after_commit" ]; then
        echo -e "${BLUE}...${RESET} ${GREEN}✓ up to date${RESET}${upgrade_note}"
    else
        if [ -z "${before_commits[$i]}" ]; then
            commit_count="1"
            file_count="0"
        else
            commit_count=$(git rev-list --count "${before_commits[$i]}..$after_commit" 2>/dev/null || echo "1")
            file_count=$(git diff --name-only "${before_commits[$i]}..$after_commit" 2>/dev/null | wc -l | tr -d ' ')
        fi
        [[ "$commit_count" =~ ^[0-9]+$ ]] || commit_count="1"
        [[ "$file_count" =~ ^[0-9]+$ ]] || file_count="0"
        commit_str="commits"
        [ "$commit_count" -eq 1 ] && commit_str="commit"
        file_str="files"
        [ "$file_count" -eq 1 ] && file_str="file"
        echo -e "${BLUE}...${RESET} ${CYAN}↓ pulled $commit_count $commit_str affecting $file_count $file_str${RESET}${upgrade_note}"
    fi

    # Clean up temp files
    rm -f "${tmp_files[$i]}"
done

echo ""
echo -e "    ${GREEN}↻  Repository sync complete.${RESET}\n"

# ---------- Clone Missing Repositories ----------
if command -v gh >/dev/null 2>&1; then
    if gh auth status >/dev/null 2>&1; then
        clone_choice="n"
        if [ -t 0 ]; then
            print_box "❏  Missing Repositories" "$BLUE" "$CYAN"
            printf "\n    ${CYAN}Would you like to clone missing remote repositories? (y/n): ${RESET}"
            read -r clone_choice
            echo ""
        fi
        
        if [[ ! "$clone_choice" =~ ^[Yy]$ ]]; then
            echo -e "    ${BLUE}No repositories cloned.${RESET}\n"
        else
        # Construct an array of local remote URLs (normalized/lowercase)
        local_urls=()
        for repo_dir in "${repos[@]}"; do
            if [ -d "$repo_dir/.git" ]; then
                url=$(cd "$repo_dir" && git remote get-url origin 2>/dev/null)
                if [ -n "$url" ]; then
                    # Standardize all remotes to git@github.com: format for consistent string matching
                    url=$(echo "$url" | sed -e 's|https://github.com/|git@github.com:|' -e 's|ssh://git@github.com/|git@github.com:|')
                    
                    # Remove .git suffix and enforce lowercase
                    url="${url%.git}"
                    url=$(echo "$url" | tr '[:upper:]' '[:lower:]')
                    
                    local_urls+=("$url")
                fi
            fi
        done
        
        missing_repos=()
        missing_urls=()
        GH_DISCOVERY_FAILED=0
        GH_DISCOVERY_REASON=""

        # Fetch remote repos from GitHub using gh asynchronously with spinner
        GH_REPO_LIST_FILE="$(mktemp 2>/dev/null || true)"
        if [ -z "$GH_REPO_LIST_FILE" ]; then
            GH_DISCOVERY_FAILED=1
            GH_DISCOVERY_REASON="tempfile"
        else
            gh repo list --limit 1000 --json nameWithOwner,sshUrl --jq '.[] | "\(.nameWithOwner)|\(.sshUrl)"' > "$GH_REPO_LIST_FILE" 2>/dev/null &
            gh_pid=$!

            spinner=( "⠋" "⠙" "⠹" "⠸" "⠼" "⠴" "⠦" "⠧" "⠇" "⠏" )
            spin_idx=0

            while kill -0 "$gh_pid" 2>/dev/null; do
                if [ "$IS_TTY" -eq 1 ]; then
                    printf "\r    ${BLUE}%s  Fetching your repository list from GitHub...${RESET}" "${spinner[$spin_idx]}"
                fi
                spin_idx=$(( (spin_idx + 1) % 10 ))
                sleep 0.1
            done

            # Clear the spinner line
            if [ "$IS_TTY" -eq 1 ]; then
                printf "\r\033[K"
            fi
            wait "$gh_pid" 2>/dev/null
            gh_result=$?

            if [ "$gh_result" -ne 0 ]; then
                GH_DISCOVERY_FAILED=1
                GH_DISCOVERY_REASON="gh_command"
            else
                echo -e "    ${BLUE}✓  Fetched repository list from GitHub.${RESET}"

                remote_repos="$(cat "$GH_REPO_LIST_FILE")"
                rm -f "$GH_REPO_LIST_FILE"
                GH_REPO_LIST_FILE=""

                while IFS="|" read -r name_with_owner ssh_url; do
                    [ -z "$name_with_owner" ] && continue

                    check_url="${ssh_url%.git}"
                    check_url=$(echo "$check_url" | tr '[:upper:]' '[:lower:]')

                    found=0
                    for l_url in "${local_urls[@]}"; do
                        if [ "$l_url" == "$check_url" ]; then
                            found=1
                            break
                        fi
                    done

                    if [ $found -eq 0 ]; then
                        missing_repos+=("$name_with_owner")
                        missing_urls+=("$ssh_url")
                    fi
                done <<< "$remote_repos"
            fi
        fi

        if [ "$GH_DISCOVERY_FAILED" -eq 1 ]; then
            if [ "$GH_DISCOVERY_REASON" = "tempfile" ]; then
                echo -e "    ${RED}× Unable to create a temporary file for GitHub repository discovery.${RESET}\n"
            else
                echo -e "    ${RED}× Unable to fetch your repository list from GitHub right now.${RESET}\n"
            fi
            echo -e "    ${BLUE}No repositories cloned.${RESET}\n"
        elif [ ${#missing_repos[@]} -gt 0 ]; then
            SELECTED_REPOS=""
            CLONE_DIR=""

            HAS_GUI=0
            if [ "$FORCE_CLI" -eq 0 ]; then
                if [[ "$OS" == "Darwin" ]] && [ -z "$SSH_CLIENT" ] && [ -z "$SSH_TTY" ]; then
                    HAS_GUI=1
                elif [[ "$OS" == "Linux" ]] && { [ -n "$DISPLAY" ] || [ -n "$WAYLAND_DISPLAY" ]; }; then
                    HAS_GUI=1
                fi
            fi

            if [ "$HAS_GUI" -eq 1 ]; then
                if [[ "$OS" == "Darwin" ]]; then
                    # macOS GUI
                    echo -ne "\n    \033[3mPlease interact with the pop-up...\033[0m"
                    repo_list_str=""
                    for repo in "${missing_repos[@]}"; do
                        repo_clean="$(escape_applescript_string "$repo")"
                        repo_list_str+="\"$repo_clean\","
                    done
                    repo_list_str="${repo_list_str%,}"
                    
                    SELECTED_REPOS=$(osascript -e "
                        try
                            set repoList to {$repo_list_str}
                            set chosen to choose from list repoList with prompt \"Select repositories to clone:\" with title \"Clone Missing Repositories\" with multiple selections allowed
                            if chosen is not false then
                                set AppleScript's text item delimiters to \"|\"
                                return chosen as text
                            else
                                return \"\"
                            end if
                        on error
                            return \"\"
                        end try
                    " 2>/dev/null || echo "")
                    
                    if [ -n "$SELECTED_REPOS" ]; then
                        if [ ${#BASE_DIRS[@]} -eq 1 ]; then
                            CLONE_DIR="${BASE_DIRS[0]}"
                        else
                            dir_list_str=""
                            for dir in "${BASE_DIRS[@]}"; do
                                dir_clean="$(escape_applescript_string "$dir")"
                                dir_list_str+="\"$dir_clean\","
                            done
                            dir_list_str="${dir_list_str%,}"
                            
                            CLONE_DIR=$(osascript -e "
                                try
                                    set dirList to {$dir_list_str}
                                    set chosen to choose from list dirList with prompt \"Select destination for cloned repositories:\" with title \"Clone Destination\" without multiple selections allowed
                                    if chosen is not false then
                                        return item 1 of chosen
                                    else
                                        return \"\"
                                    end if
                                on error
                                    return \"\"
                                end try
                            " 2>/dev/null || echo "")
                        fi
                    fi
                    echo -ne "\r\033[K\033[1A\r\033[K"
                    
                elif [[ "$OS" == "Linux" ]]; then
                    # Linux GUI
                    if command -v zenity >/dev/null; then
                        echo -ne "\n    \033[3mPlease interact with the pop-up...\033[0m"
                        list_args=()
                        for repo in "${missing_repos[@]}"; do
                            list_args+=(FALSE "$repo")
                        done
                        
                        selected=$(zenity --list --checklist --title="Clone Missing Repositories" --text="Select repositories to clone:" --column="Clone" --column="Repository" "${list_args[@]}" --separator="|" 2>/dev/null)
                        if [ -n "$selected" ]; then
                            SELECTED_REPOS="$selected"
                            
                            if [ ${#BASE_DIRS[@]} -eq 1 ]; then
                                CLONE_DIR="${BASE_DIRS[0]}"
                            else
                                dir_args=()
                                for dir in "${BASE_DIRS[@]}"; do
                                    dir_args+=(FALSE "$dir")
                                done
                                dir_args[0]="TRUE"
                                
                                CLONE_DIR=$(zenity --list --radiolist --title="Clone Destination" --text="Select destination for cloned repositories:" --column="Select" --column="Directory" "${dir_args[@]}" 2>/dev/null)
                            fi
                        fi
                        echo -ne "\r\033[K\033[1A\r\033[K"
                    elif command -v kdialog >/dev/null; then
                        echo -ne "\n    \033[3mPlease interact with the pop-up...\033[0m"
                        list_args=()
                        for repo in "${missing_repos[@]}"; do
                            list_args+=("$repo" "$repo" "off")
                        done
                        
                        selected=$(kdialog --checklist "Select repositories to clone:" "${list_args[@]}" --title "Clone Missing Repositories" --separator="|" 2>/dev/null)
                        if [ -n "$selected" ]; then
                            SELECTED_REPOS=$(echo "$selected" | tr -d '"')
                            
                            if [ ${#BASE_DIRS[@]} -eq 1 ]; then
                                CLONE_DIR="${BASE_DIRS[0]}"
                            else
                                dir_args=()
                                for dir in "${BASE_DIRS[@]}"; do
                                    dir_args+=("$dir" "$dir" "off")
                                done
                                dir_args[2]="on"
                                
                                CLONE_DIR=$(kdialog --radiolist "Select destination for cloned repositories:" "${dir_args[@]}" --title "Clone Destination" 2>/dev/null)
                                CLONE_DIR=$(echo "$CLONE_DIR" | tr -d '"')
                            fi
                        fi
                        echo -ne "\r\033[K\033[1A\r\033[K"
                    else
                        HAS_GUI=0
                    fi
                fi
            fi
            
            # Fallback to terminal prompt if no GUI tool was available
            if [ "$HAS_GUI" -eq 0 ]; then
                echo ""
                if [ "${#missing_repos[@]}" -eq 1 ]; then
                    echo -e "    ${YELLOW}You have 1 repository on GitHub that is not cloned locally:${RESET}"
                else
                    echo -e "    ${YELLOW}You have ${#missing_repos[@]} repositories on GitHub that are not cloned locally:${RESET}"
                fi
                echo ""
                for i in "${!missing_repos[@]}"; do
                    # Strip the github username from the repo string
                    repo_name_only=$(basename "${missing_repos[$i]}")
                    echo -e "      ${BLUE}$((i+1)))${RESET} ${repo_name_only}"
                done
                echo ""
                if [ -t 0 ]; then
                    read -p "$(echo -e "    ${CYAN}Enter comma-separated numbers to clone (1-${#missing_repos[@]}): ${RESET}")" -r choices
                    if [ -n "$choices" ]; then
                        IFS=',' read -ra CH_ARR <<< "$choices"
                        for c in "${CH_ARR[@]}"; do
                            # cross-platform trim
                            c=$(echo "$c" | awk '{$1=$1};1')
                            if [[ "$c" =~ ^[0-9]+$ ]] && [ "$c" -ge 1 ] && [ "$c" -le "${#missing_repos[@]}" ]; then
                                SELECTED_REPOS+="${missing_repos[$((c-1))]}|"
                            fi
                        done
                        SELECTED_REPOS="${SELECTED_REPOS%|}"
                        
                        if [ -n "$SELECTED_REPOS" ]; then
                            if [ ${#BASE_DIRS[@]} -gt 1 ]; then
                                CLONE_DIR=""
                                echo ""
                                echo -e "    ${YELLOW}Available directories for cloning:${RESET}\n"
                                for i in "${!BASE_DIRS[@]}"; do
                                    echo -e "      ${BLUE}$((i+1)))${RESET} ${BASE_DIRS[$i]}"
                                done
                                echo ""
                                read -p "$(echo -e "    ${CYAN}Select a directory (1-${#BASE_DIRS[@]}): ${RESET}")" -r dir_choice
                                if [[ "$dir_choice" =~ ^[0-9]+$ ]] && [ "$dir_choice" -ge 1 ] && [ "$dir_choice" -le "${#BASE_DIRS[@]}" ]; then
                                    CLONE_DIR="${BASE_DIRS[$((dir_choice-1))]}"
                                fi
                            else
                                CLONE_DIR="${BASE_DIRS[0]}"
                            fi
                        fi
                    fi
                fi
            fi

            if [ -n "$SELECTED_REPOS" ] && [ -n "$CLONE_DIR" ]; then
                echo ""
                mkdir -p "$CLONE_DIR"
                
                IFS='|' read -ra SEL_ARR <<< "$SELECTED_REPOS"
                echo -e "    ${BLUE}↓  Cloning ${#SEL_ARR[@]} repositories into $CLONE_DIR...${RESET}\n"
                
                clone_pids=()
                clone_repos=()
                
                for sel_repo in "${SEL_ARR[@]}"; do
                    target_url=""
                    for i in "${!missing_repos[@]}"; do
                        if [ "${missing_repos[$i]}" == "$sel_repo" ]; then
                            target_url="${missing_urls[$i]}"
                            break
                        fi
                    done
                    
                    if [ -n "$target_url" ]; then
                        repo_name=$(basename "$target_url" .git)
                        clone_repos+=("$repo_name")
                        
                        (cd "$CLONE_DIR" && git clone -q "$target_url" >/dev/null 2>&1) &
                        clone_pids+=($!)
                    fi
                done
                
                spinner=( "⠋" "⠙" "⠹" "⠸" "⠼" "⠴" "⠦" "⠧" "⠇" "⠏" )
                spin_idx=0
                
                while true; do
                    jobs_running=0
                    for pid in "${clone_pids[@]}"; do
                        if kill -0 "$pid" 2>/dev/null; then
                            jobs_running=1
                            break
                        fi
                    done
                    
                    if [ $jobs_running -eq 0 ]; then
                        break
                    fi
                    
                    if [ "$IS_TTY" -eq 1 ]; then
                        printf "\r    ${BLUE}%s  Cloning repositories...${RESET}" "${spinner[$spin_idx]}"
                    fi
                    spin_idx=$(( (spin_idx + 1) % 10 ))
                    sleep 0.1
                done
                
                # Clear the spinner line
                if [ "$IS_TTY" -eq 1 ]; then
                    printf "\r\033[K"
                fi
                
                display_count=1
                for i in "${!clone_pids[@]}"; do
                    wait "${clone_pids[$i]}" 2>/dev/null
                    result=$?
                    
                    repo_name="${clone_repos[$i]}"
                    printf "    ${BLUE}[%d/%d]${RESET} %s " "$display_count" "${#SEL_ARR[@]}" "$repo_name"
                    
                    if [ $result -eq 0 ]; then
                        echo -e "${BLUE}...${RESET} ${GREEN}✓ cloned${RESET}"
                    else
                        echo -e "${BLUE}...${RESET} ${RED}× failed to clone${RESET}"
                    fi
                    
                    ((display_count++))
                done
                
                echo -e "\n    ${GREEN}↓  Cloning complete.${RESET}\n"
            else
                echo -e "\n    ${BLUE}No repositories cloned.${RESET}\n"
            fi
        else
            echo -e "\n    ${GREEN}✓  All your remote repositories are already cloned locally.${RESET}\n"
        fi
        fi
    else
        print_box "❏  Missing Repositories" "$BLUE" "$CYAN"
        echo -e "\n    ${YELLOW}△  Missing-repository discovery skipped: GitHub CLI is not authenticated.${RESET}"
        echo -e "    ${CYAN}Run: gh auth login${RESET}\n"
    fi
else
    print_box "❏  Missing Repositories" "$BLUE" "$CYAN"
    echo -e "\n    ${YELLOW}△  Missing-repository discovery skipped: GitHub CLI (gh) is not installed.${RESET}"
    echo -e "    ${CYAN}Install and log in to enable it: brew install gh && gh auth login${RESET}\n"
fi

if [[ "$OS" == "Darwin" ]]; then
    osascript -e 'display notification "Repository sync complete." with title "GitHub Multi-Sync"' >/dev/null 2>&1 || true
elif [[ "$OS" == "Linux" ]]; then
    if command -v notify-send >/dev/null; then
        notify-send "GitHub Multi-Sync" "Repository sync complete."
    fi
fi

echo -e "\n    ©  2026 Sahil Kamal\n"
